{
    "track": "swe_intern",
    "company_style": "apple",
    "difficulty": "hard",
    "questions": [
      {
        "title": "Design a Privacy-Preserving Analytics System",
        "prompt": "Design an analytics system that measures feature usage while minimizing collection of sensitive user data. Discuss data minimization, aggregation, and access controls.",
        "tags": ["system-thinking", "privacy", "design"],
        "followups": [
          "What data would you refuse to collect and why?",
          "How would you support debugging without raw user data?",
          "How would you audit and monitor access to analytics?"
        ]
      },
      {
        "title": "Distributed Cache Invalidation",
        "prompt": "You have a distributed cache in front of a source of truth database. Design a strategy for invalidation and consistency under concurrent writes.",
        "tags": ["system-thinking", "distributed-systems", "design"],
        "followups": [
          "What consistency model are you targeting and why?",
          "How do you handle cache stampedes?",
          "How do you test correctness under race conditions?"
        ]
      },
      {
        "title": "Concurrent Queue (Correctness Focus)",
        "prompt": "Design a thread-safe queue supporting multiple producers and consumers. Describe how you ensure correctness and performance.",
        "tags": ["concurrency", "design", "memory"],
        "followups": [
          "How do you prevent deadlocks and starvation?",
          "When would you use lock-free vs locking?",
          "How would you validate linearizability or correctness?"
        ]
      },
      {
        "title": "Implement a File-System-like Trie",
        "prompt": "Design and implement a structure that supports creating paths and querying if a path exists (like a simplified file system).",
        "tags": ["tries", "design", "strings"],
        "followups": [
          "How do you handle deletions safely?",
          "How do you store metadata (permissions, timestamps)?",
          "What are the memory trade-offs?"
        ]
      },
      {
        "title": "Scheduler: Priorities and Fairness",
        "prompt": "Design a task scheduler that supports priorities, time slicing, and fairness (no starvation). Explain policies and trade-offs.",
        "tags": ["system-thinking", "design", "concurrency"],
        "followups": [
          "How do you measure fairness?",
          "How do you handle long-running tasks?",
          "What data structures support efficient scheduling?"
        ]
      },
      {
        "title": "Search Autocomplete with Ranking",
        "prompt": "Design an autocomplete system for a large dictionary that supports prefix queries and ranks results by popularity and recency.",
        "tags": ["system-thinking", "tries", "ranking"],
        "followups": [
          "How do you update rankings in near real-time?",
          "How do you handle memory constraints on device?",
          "What tests ensure relevance and latency targets?"
        ]
      },
      {
        "title": "On-Device Model Update Strategy",
        "prompt": "You ship an on-device ML feature. Design how you would roll out model updates safely, handle rollback, and measure impact.",
        "tags": ["product-thinking", "system-thinking", "reliability"],
        "followups": [
          "What guardrails prevent bad updates?",
          "How do you handle offline devices?",
          "How do you evaluate model quality without collecting raw user data?"
        ]
      },
      {
        "title": "Build a Crash Deduplication Pipeline",
        "prompt": "Design a backend pipeline that ingests crash reports, deduplicates them, and surfaces top issues. Consider scalability and signal quality.",
        "tags": ["system-thinking", "design", "debugging"],
        "followups": [
          "What defines a duplicate crash signature?",
          "How do you handle noisy stack traces (inlining, symbol changes)?",
          "How do you prioritize what engineers fix first?"
        ]
      },
      {
        "title": "Memory: ARC/GC + Performance Trade-offs",
        "prompt": "Explain how reference counting (ARC-like) compares to tracing garbage collection for latency-sensitive apps. Discuss pauses, fragmentation, and cycles.",
        "tags": ["memory", "performance", "fundamentals"],
        "followups": [
          "How do retain cycles happen and how do you break them?",
          "What patterns reduce allocation churn?",
          "How do you measure and tune memory in production?"
        ]
      },
      {
        "title": "Design a Real-Time Collaboration Engine",
        "prompt": "Design a simplified real-time collaboration system (like shared notes) that supports concurrent edits and conflict resolution.",
        "tags": ["distributed-systems", "design", "system-thinking"],
        "followups": [
          "Compare OT vs CRDT at a high level.",
          "How do you handle offline edits and re-merge?",
          "What are the minimal correctness guarantees you must provide?"
        ]
      },
      {
        "title": "High-Performance Image Pipeline",
        "prompt": "Design a pipeline that loads images, transforms them (resize/crop), and renders smoothly under memory and latency constraints.",
        "tags": ["performance", "system-thinking", "design"],
        "followups": [
          "How do you avoid UI jank and blocking the main thread?",
          "What caching strategy would you use (memory/disk)?",
          "How do you test performance regressions?"
        ]
      },
      {
        "title": "Implement a Mini Regex Engine",
        "prompt": "Implement a simplified regex matcher supporting '.' and '*' operators. Focus on correctness and complexity.",
        "tags": ["dp", "strings", "algorithms"],
        "followups": [
          "Why does naive backtracking blow up?",
          "How do you implement DP and what is the state?",
          "What test cases catch tricky bugs?"
        ]
      },
      {
        "title": "Design a Secure Token System",
        "prompt": "Design a token-based authentication system for a mobile app and backend. Consider token rotation, expiration, and storage.",
        "tags": ["security", "system-thinking", "design"],
        "followups": [
          "How do you store tokens securely on-device?",
          "How do you handle compromised tokens?",
          "What logs/telemetry do you collect without leaking secrets?"
        ]
      },
      {
        "title": "Rate Limiting at Scale (Distributed)",
        "prompt": "Design a distributed rate limiter for millions of users across multiple regions. Focus on correctness under failures.",
        "tags": ["distributed-systems", "design", "system-thinking"],
        "followups": [
          "How do you avoid a single point of failure?",
          "What consistency trade-offs are acceptable?",
          "How do you handle clock skew and burstiness?"
        ]
      },
      {
        "title": "Build a Dependency Graph Resolver",
        "prompt": "Given packages with dependencies, determine an installation order or report a cycle. Extend to version constraints at a high level.",
        "tags": ["graphs", "topological-sort", "design"],
        "followups": [
          "How do you detect and report cycles clearly?",
          "How does this change with optional dependencies?",
          "What are performance constraints for large graphs?"
        ]
      },
      {
        "title": "Design Review: Latency Budget",
        "prompt": "A feature must respond within 16ms to stay smooth. How do you design, measure, and keep within a latency budget?",
        "tags": ["performance", "system-thinking", "communication"],
        "followups": [
          "What do you profile first and why?",
          "How do you prevent regressions over time?",
          "How do you handle trade-offs between CPU, memory, and battery?"
        ]
      },
      {
        "title": "Consistency vs Availability Decision",
        "prompt": "You are designing a sync service. Explain a scenario where you prefer stronger consistency and one where you prefer higher availability.",
        "tags": ["distributed-systems", "system-thinking", "design"],
        "followups": [
          "What failure modes change your choice?",
          "How do you communicate these trade-offs to non-engineers?",
          "What metrics reveal user pain from inconsistency?"
        ]
      },
      {
        "title": "Debugging: Heisenbug in Production",
        "prompt": "A bug disappears when logging is enabled and happens only under load. Describe a strategy to identify root cause and ship a safe fix.",
        "tags": ["debugging", "concurrency", "reliability"],
        "followups": [
          "What signals do you add without perturbing timing too much?",
          "How do you reproduce issues deterministically?",
          "How do you roll out and validate the fix safely?"
        ]
      },
      {
        "title": "Design a Fault-Tolerant Upload System",
        "prompt": "Design a resumable upload system for large files on unreliable mobile networks. Include retries, chunking, and integrity checks.",
        "tags": ["system-thinking", "design", "reliability"],
        "followups": [
          "How do you ensure idempotency of chunk uploads?",
          "How do you handle partial failures and cleanup?",
          "How do you detect corruption and verify integrity end-to-end?"
        ]
      },
      {
        "title": "Security + Privacy: Local Data Storage",
        "prompt": "You need to store user-sensitive data locally. Design how you would encrypt at rest, manage keys, and handle device compromise scenarios.",
        "tags": ["security", "privacy", "system-thinking"],
        "followups": [
          "Where do keys live and how are they rotated?",
          "How do you balance usability vs security (biometrics, lockouts)?",
          "What is your incident response if a vulnerability is discovered?"
        ]
      }
    ]
  }
  